Index: fw4/hw/at90usbxx2/at90usb.h
===================================================================
--- fw4.orig/hw/at90usbxx2/at90usb.h	2011-02-08 15:58:49.000000000 -0300
+++ fw4/hw/at90usbxx2/at90usb.h	2011-02-08 15:59:22.000000000 -0300
@@ -42,14 +42,6 @@
 
 #define AT90USB16
 
-#define VBUS_SENSE_DDR      DDRB
-#define VBUS_SENSE_PORT     PORTB
-#define VBUS_SENSE_PIN      PINB
-#define VBUS_SENSE_IO       5
-
-// test if vbus is present
-#define is_vbus_on()        ((VBUS_SENSE_PIN & (1<<VBUS_SENSE_IO)) != 0)
-
 // banks
 #define SINGLE          0
 #define DUAL            1
Index: fw4/hw/at90usbxx2/hw.c
===================================================================
--- fw4.orig/hw/at90usbxx2/hw.c	2011-02-08 15:57:56.000000000 -0300
+++ fw4/hw/at90usbxx2/hw.c	2011-02-08 16:00:31.000000000 -0300
@@ -85,26 +85,14 @@
     // set the interrupts: vbus, suspend, and end of reset
     UDIEN  |= (_BV(SUSPE) | _BV(EORSTE));
 
-    // enable vbus sense pin
-    VBUS_SENSE_DDR  &= ~_BV(VBUS_SENSE_IO);
-    VBUS_SENSE_PORT &= ~_BV(VBUS_SENSE_IO);
-
-    // enable the vbus sense interrupt
-    PCICR |= _BV(PCIE0);
-    PCMSK0 |= _BV(PCINT5);
-
-    // do an initial check to see if bus power is available. we
-    // need this because we'll miss the first transition to vbus on
-    if (is_vbus_on())
-    {
-        pcb->connected = true;
+    /* we're bus-powered, so VBUS is on by definition */
+    pcb->connected = true;
 
-        // attach USB
-        UDCON &= ~_BV(DETACH);
+    // attach USB
+    UDCON &= ~_BV(DETACH);
     
-        // reset CPU
-        //UDCON |= _BV(RSTCPU);
-    }
+    // reset CPU
+    //UDCON |= _BV(RSTCPU);
 
     // turn on the global interrupts
     sei();
Index: fw4/hw/at90usbxx2/isr.c
===================================================================
--- fw4.orig/hw/at90usbxx2/isr.c	2011-02-08 16:00:34.000000000 -0300
+++ fw4/hw/at90usbxx2/isr.c	2011-02-08 16:00:56.000000000 -0300
@@ -249,60 +249,3 @@
 
     sei();
 }
-
-/**************************************************************************/
-/*!
-    This ISR is only for the AT90USB16 since we need to use an IO as the VBUS sense
-*/
-/**************************************************************************/
-ISR(PCINT0_vect)
-{
-    usb_pcb_t *pcb = usb_pcb_get();
-
-    cli();
-
-    if (is_vbus_on())
-    {
-        pcb->connected = true;
-
-        // enable the 3.3V regulator for the USB pads
-        REGCR &= ~_BV(REGDIS);
-
-        // freeze the clock
-        USBCON |= _BV(FRZCLK);
-        
-        // enable the 48 MHz PLL
-        PLLCSR &= ~(_BV(PLLP2) | _BV(PLLP1) | _BV(PLLP0)); 
-        PLLCSR |= _BV(1<<PLLE);
-    
-        // busy wait until the PLL is locked
-        while (!(PLLCSR & _BV(PLOCK)));
-    
-        // unfreeze clock
-        USBCON &= ~_BV(FRZCLK);
-    
-        // attach USB
-        UDCON &= ~_BV(DETACH);
-    
-        // reset CPU
-        UDCON |= _BV(RSTCPU);
-    }
-    else
-    {
-        // if we're connected, but VBUS is gone, then detach
-
-        // detach from the bus
-        UDCON  |= _BV(DETACH);
-
-        // freeze the clock and turn off the USB PLL
-        USBCON |= _BV(FRZCLK);
-        PLLCSR &= ~_BV(PLLE);
-
-        // disable the USB voltage regulator
-        REGCR |= _BV(REGDIS);
-
-        pcb->connected = false;
-        pcb->flags = 0;
-    }
-    sei();
-}
