Index: fw4/hw/at90usbxx2/ep.c
===================================================================
--- fw4.orig/hw/at90usbxx2/ep.c	2011-02-08 17:13:41.000000000 -0300
+++ fw4/hw/at90usbxx2/ep.c	2011-02-08 17:13:46.000000000 -0300
@@ -56,7 +56,7 @@
     Get the max packet size of the endpoint.
 */
 /**************************************************************************/
-U8 ep_size_get()
+static U8 ep_size_get(void)
 {
     U8 tmp = (UECFG1X &= (7<<EPSIZE0));
     tmp >>= EPSIZE0;
@@ -68,7 +68,7 @@
     Get the direction of the endpoint.
 */
 /**************************************************************************/
-U8 ep_dir_get()
+static U8 ep_dir_get(void)
 {
     return (UECFG0X & 0x1);
 }
@@ -78,7 +78,7 @@
     Get the endpoint type: BULK, CONTROL, INTERRUPT, ISOCHRONOUS
 */
 /**************************************************************************/
-U8 ep_type_get()
+static U8 ep_type_get(void)
 {
     return ((UECFG0X & (0x3 << EPTYPE0)) >> EPTYPE0);
 }
@@ -88,8 +88,9 @@
     Clear the endpoint configuration registers
 */
 /**************************************************************************/
-void ep_cfg_clear()
+static void ep_cfg_clear(U8 ep_num)
 {
+    ep_select(ep_num);
     UECFG0X = 0;
     UECFG1X = 0;
 }
@@ -99,8 +100,9 @@
     Clear the specified endpoint's enable bit.
 */
 /**************************************************************************/
-void ep_disable()
+static void ep_disable(U8 ep_num)
 {
+    ep_select(ep_num);
     UECONX &= ~(1 << EPEN);
 }
 
@@ -279,7 +281,7 @@
     Clear all endpoints and initialize ep0 for control transfers.
 */
 /**************************************************************************/
-void ep_init()
+void ep_init(void)
 {
     U8 i;
 
@@ -328,7 +330,7 @@
     Return the ep where an intp occurred. If no intp occurred, then return 0xff.
 */
 /**************************************************************************/
-U8 ep_intp_get_num()
+U8 ep_intp_get_num(void)
 {
     U8 i;
 
@@ -348,7 +350,7 @@
     is found, return 0xFF.
 */
 /**************************************************************************/
-U8 ep_intp_get_src()
+U8 ep_intp_get_src(void)
 {
     U8 i;
 
Index: fw4/hw/at90usbxx2/hw.c
===================================================================
--- fw4.orig/hw/at90usbxx2/hw.c	2011-02-08 17:13:41.000000000 -0300
+++ fw4/hw/at90usbxx2/hw.c	2011-02-08 17:13:46.000000000 -0300
@@ -53,7 +53,7 @@
     4) Enable the global interrupt.
 */
 /**************************************************************************/
-void hw_init()
+void hw_init(void)
 {
     usb_pcb_t *pcb = usb_pcb_get();
 
@@ -126,7 +126,7 @@
     Disable global interrupts
 */
 /**************************************************************************/
-void hw_intp_disable()
+void hw_intp_disable(void)
 {
     cli();
 }
@@ -136,7 +136,7 @@
     Enable global interrupts
 */
 /**************************************************************************/
-void hw_intp_enable()
+void hw_intp_enable(void)
 {
     sei();
 }
Index: fw4/hw/at90usbxx2/hw.h
===================================================================
--- fw4.orig/hw/at90usbxx2/hw.h	2011-02-08 17:13:41.000000000 -0300
+++ fw4/hw/at90usbxx2/hw.h	2011-02-08 17:13:46.000000000 -0300
@@ -38,9 +38,9 @@
 #ifndef HW_H
 #define HW_H
 
-void hw_init();
-void hw_intp_disable();
-void hw_intp_enable();
+void hw_init(void);
+void hw_intp_disable(void);
+void hw_intp_enable(void);
 U8 hw_flash_get_byte(U8 *addr);
 
 #endif
Index: fw4/usb/ctrl.c
===================================================================
--- fw4.orig/usb/ctrl.c	2011-02-08 17:13:41.000000000 -0300
+++ fw4/usb/ctrl.c	2011-02-08 17:14:46.000000000 -0300
@@ -48,7 +48,7 @@
     returning the relevant descriptor stored in flash.
 */
 /**************************************************************************/
-void ctrl_get_desc(req_t *req)
+static void ctrl_get_desc(req_t *req)
 {
     U8 i = 0, desc_len = 0, desc_type, desc_idx;
     U8 *desc = NULL;
@@ -117,7 +117,7 @@
     Return the device configuration number to the host.
 */
 /**************************************************************************/
-void ctrl_get_config()
+static void ctrl_get_config(void)
 {
     usb_pcb_t *pcb = usb_pcb_get();
 
@@ -130,7 +130,7 @@
     Return the status of the device or endpoint to the host.
 */
 /**************************************************************************/
-void ctrl_get_status(req_t *req)
+static void ctrl_get_status(req_t *req)
 {
     U8 i, rem_wake_enb = 0;
     U8 status[2];
@@ -174,7 +174,7 @@
     which will setup the endpoints according to the device class.
 */
 /**************************************************************************/
-void ctrl_set_config(req_t *req)
+static void ctrl_set_config(req_t *req)
 {
     usb_pcb_t *pcb;
 
@@ -201,7 +201,7 @@
     stall the specified endpoint.
 */
 /**************************************************************************/
-void ctrl_set_feat(req_t *req)
+static void ctrl_set_feat(req_t *req)
 {
     usb_pcb_t *pcb = usb_pcb_get();
 
@@ -230,7 +230,7 @@
     don't do anything with the flag.
 */
 /**************************************************************************/
-void ctrl_clear_feat(req_t *req)
+static void ctrl_clear_feat(req_t *req)
 {
     usb_pcb_t *pcb = usb_pcb_get();
 
@@ -261,7 +261,7 @@
     then we'll stall the endpoint.
 */
 /**************************************************************************/
-void ctrl_handler()
+void ctrl_handler(void)
 {
     usb_pcb_t *pcb = usb_pcb_get();
     U8 i, req[CTRL_IN_REQ_SZ];
Index: fw4/usb/freakusb.h
===================================================================
--- fw4.orig/usb/freakusb.h	2011-02-08 17:13:41.000000000 -0300
+++ fw4/usb/freakusb.h	2011-02-08 17:13:46.000000000 -0300
@@ -213,35 +213,35 @@
     U8 pending_data;
     U8 test;
     usb_buffer_t fifo[NUM_EPS];
-    void (*class_init)();
+    void (*class_init)(void);
     void (*class_req_handler)(req_t *req);
-    void (*class_rx_handler)();
+    void (*class_rx_handler)(void);
 } usb_pcb_t;
 
 // prototypes
 
 // usb.c
-void usb_init();
-usb_pcb_t *usb_pcb_get();
-void usb_reg_class_drvr(void (*class_cfg_init)(),
-                        void (*class_req_handler)(),
-                        void (*class_rx_handler)());
-void usb_poll();
-bool usb_ready();
+void usb_init(void);
+usb_pcb_t *usb_pcb_get(void);
+void usb_reg_class_drvr(void (*class_cfg_init)(void),
+                        void (*class_req_handler)(req_t *req),
+                        void (*class_rx_handler)(void));
+void usb_poll(void);
+bool usb_ready(void);
 
 // req.c
-void ctrl_handler();
+void ctrl_handler(void);
 
 // ep.c
-void ep_init();
+void ep_init(void);
 void ep_select(U8 ep_num);
 void ep_write_from_flash(U8 ep_num, U8 *data, U8 len);
 void ep_write(U8 ep_num);
 void ep_write_ctrl(U8 *data, U8 len, bool read_from_flash);
 void ep_read(U8 ep_num);
 void ep_set_addr(U8 addr);
-U8 ep_intp_get_num();
-U8 ep_intp_get_src();
+U8 ep_intp_get_num(void);
+U8 ep_intp_get_src(void);
 void ep_set_stall(U8 ep_num);
 void ep_clear_stall(U8 ep_num);
 void ep_reset_toggle(U8 ep_num);
@@ -250,12 +250,12 @@
 void ep_drain_fifo(U8 ep);
 
 // desc.c
-U8 *desc_dev_get();
-U8 desc_dev_get_len();
-U8 *desc_cfg_get();
-U8 desc_cfg_get_len();
-U8 *desc_dev_qual_get();
-U8 desc_dev_qual_get_len();
+U8 *desc_dev_get(void);
+U8 desc_dev_get_len(void);
+U8 *desc_cfg_get(void);
+U8 desc_cfg_get_len(void);
+U8 *desc_dev_qual_get(void);
+U8 desc_dev_qual_get_len(void);
 U8 *desc_str_get(U8 index);
 U8 desc_str_get_len(U8 index);
 
Index: fw4/usb/usb.c
===================================================================
--- fw4.orig/usb/usb.c	2011-02-08 17:13:41.000000000 -0300
+++ fw4/usb/usb.c	2011-02-08 17:13:46.000000000 -0300
@@ -47,7 +47,7 @@
     block for now.
 */
 /**************************************************************************/
-void usb_init()
+void usb_init(void)
 {
     memset(&pcb, 0, sizeof(usb_pcb_t));
 }
@@ -57,7 +57,7 @@
     Get a pointer to the USB stack's protocol control block.
 */
 /**************************************************************************/
-usb_pcb_t *usb_pcb_get()
+usb_pcb_t *usb_pcb_get(void)
 {
     return &pcb;
 }
@@ -67,9 +67,9 @@
     Register the class driver
 */
 /**************************************************************************/
-void usb_reg_class_drvr(void (*class_init)(),
+void usb_reg_class_drvr(void (*class_init)(void),
                         void (*class_req_handler)(req_t *req),
-                        void (*class_rx_handler)())
+                        void (*class_rx_handler)(void))
 {
     pcb.class_req_handler   = class_req_handler;
     pcb.class_init          = class_init;
@@ -83,7 +83,7 @@
     there are any pending CONTROL transfers.
 */
 /**************************************************************************/
-void usb_poll()
+void usb_poll(void)
 {
     U8 i, ep_num;
 
Index: fw4/hw/at90usbxx2/isr.c
===================================================================
--- fw4.orig/hw/at90usbxx2/isr.c	2011-02-08 17:13:41.000000000 -0300
+++ fw4/hw/at90usbxx2/isr.c	2011-02-08 17:13:46.000000000 -0300
@@ -44,7 +44,7 @@
     Clear all USB related interrupts.
 */
 /**************************************************************************/
-void intp_clear_all()
+static void intp_clear_all(void)
 {
     U8 i;
 
@@ -62,7 +62,7 @@
     Suspend interrupt handler.
 */
 /**************************************************************************/
-void intp_suspend()
+static void intp_suspend(void)
 {
     SUSP_INT_CLR();
     WAKEUP_INT_ENB();
@@ -77,7 +77,7 @@
     Resume interrupt handler.
 */
 /**************************************************************************/
-void intp_resume()
+static void intp_resume(void)
 {
     WAKEUP_INT_DIS();
     RESM_INT_CLR();
@@ -89,7 +89,7 @@
     Wakeup interrupt handler.
 */
 /**************************************************************************/
-void intp_wakeup()
+static void intp_wakeup(void)
 {
     // unfreeze the clock
     USBCON &= ~(1 << FRZCLK);
@@ -106,7 +106,7 @@
     End of Reset interrupt handler. Gets triggered at the end of a bus reset.
 */
 /**************************************************************************/
-void intp_eor()
+static void intp_eor(void)
 {
     EOR_INT_CLR();
     ep_init();
Index: fw4/class/CDC/cdc.c
===================================================================
--- fw4.orig/class/CDC/cdc.c	2011-02-08 17:18:36.000000000 -0300
+++ fw4/class/CDC/cdc.c	2011-02-08 17:18:59.000000000 -0300
@@ -63,7 +63,7 @@
 
 // this is the rx handler callback function. it gets registered by the application program
 // and will handle any incoming data.
-static void (*rx_handler)();
+static void (*rx_handler)(void);
 
 /**************************************************************************/
 /*!
@@ -139,7 +139,7 @@
     virtual COM data.
 */
 /**************************************************************************/
-void cdc_rx_handler()
+void cdc_rx_handler(void)
 {
     if (rx_handler)
     {
@@ -154,7 +154,7 @@
     usually set this after the host issues the set_configuration request.
 */
 /**************************************************************************/
-void cdc_ep_init()
+void cdc_ep_init(void)
 {
     // setup the endpoints
     ep_config(EP_1, BULK, DIR_IN, MAX_PACKET_SZ);
@@ -168,7 +168,7 @@
     function here since the CDC doesn't know what to do with received data.
 */
 /**************************************************************************/
-void cdc_reg_rx_handler(void (*rx)())
+void cdc_reg_rx_handler(void (*rx)(void))
 {
     if (rx)
     {
@@ -212,7 +212,7 @@
     and rx data handler with the USB core.
 */
 /**************************************************************************/
-void cdc_init()
+void cdc_init(void)
 {
     // hook the putchar function into the printf stdout filestream. This is needed
     // for printf to work.
